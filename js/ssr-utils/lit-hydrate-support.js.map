{
  "version": 3,
  "sources": ["../../../node_modules/lit-html/src/private-ssr-support.ts", "../../../node_modules/@lit-labs/ssr-client/src/lib/hydrate-lit-html.ts", "../../../node_modules/@lit-labs/ssr-client/src/lit-element-hydrate-support.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {\n  Directive,\n  PartInfo,\n  DirectiveClass,\n  DirectiveResult,\n} from './directive.js';\nimport {\n  _$LH as p,\n  AttributePart,\n  noChange,\n  Part,\n  Disconnectable,\n} from './lit-html.js';\n\nimport type {\n  PropertyPart,\n  ChildPart,\n  BooleanAttributePart,\n  EventPart,\n  ElementPart,\n  TemplateInstance,\n} from './lit-html.js';\n\n/**\n * END USERS SHOULD NOT RELY ON THIS OBJECT.\n *\n * We currently do not make a mangled rollup build of the lit-ssr code. In order\n * to keep a number of (otherwise private) top-level exports mangled in the\n * client side code, we export a _$LH object containing those members (or\n * helper methods for accessing private fields of those members), and then\n * re-export them for use in lit-ssr. This keeps lit-ssr agnostic to whether the\n * client-side code is being used in `dev` mode or `prod` mode.\n * @private\n */\nexport const _$LH = {\n  boundAttributeSuffix: p._boundAttributeSuffix,\n  marker: p._marker,\n  markerMatch: p._markerMatch,\n  HTML_RESULT: p._HTML_RESULT,\n  getTemplateHtml: p._getTemplateHtml,\n  overrideDirectiveResolve: (\n    directiveClass: new (part: PartInfo) => Directive & {render(): unknown},\n    resolveOverrideFn: (directive: Directive, values: unknown[]) => unknown\n  ) =>\n    class extends directiveClass {\n      override _$resolve(\n        this: Directive,\n        _part: Part,\n        values: unknown[]\n      ): unknown {\n        return resolveOverrideFn(this, values);\n      }\n    },\n  setDirectiveClass(value: DirectiveResult, directiveClass: DirectiveClass) {\n    // This property needs to remain unminified.\n    value['_$litDirective$'] = directiveClass;\n  },\n  getAttributePartCommittedValue: (\n    part: AttributePart,\n    value: unknown,\n    index: number | undefined\n  ) => {\n    // Use the part setter to resolve directives/concatenate multiple parts\n    // into a final value (captured by passing in a commitValue override)\n    let committedValue: unknown = noChange;\n    // Note that _commitValue need not be in `stableProperties` because this\n    // method is only run on `AttributePart`s created by lit-ssr using the same\n    // version of the library as this file\n    part._commitValue = (value: unknown) => (committedValue = value);\n    part._$setValue(value, part, index);\n    return committedValue;\n  },\n  connectedDisconnectable: (props?: object): Disconnectable => ({\n    ...props,\n    _$isConnected: true,\n  }),\n  resolveDirective: p._resolveDirective,\n  AttributePart: p._AttributePart,\n  PropertyPart: p._PropertyPart as typeof PropertyPart,\n  BooleanAttributePart: p._BooleanAttributePart as typeof BooleanAttributePart,\n  EventPart: p._EventPart as typeof EventPart,\n  ElementPart: p._ElementPart as typeof ElementPart,\n  TemplateInstance: p._TemplateInstance as typeof TemplateInstance,\n  isIterable: p._isIterable,\n  ChildPart: p._ChildPart as typeof ChildPart,\n};\n", "/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {\n  DirectiveParent,\n  RenderOptions,\n  TemplateResult,\n  noChange,\n} from 'lit-html';\nimport {_$LH} from 'lit-html/private-ssr-support.js';\nimport {\n  AttributePart,\n  AttributePartInfo,\n  PartType,\n} from 'lit-html/directive.js';\nimport {\n  isPrimitive,\n  isSingleExpression,\n  isTemplateResult,\n} from 'lit-html/directive-helpers.js';\n\n// In the Node build, this import will be injected by Rollup:\n// import {Buffer} from 'buffer';\n\nconst NODE_MODE = false;\n\nconst {TemplateInstance, isIterable, resolveDirective, ChildPart, ElementPart} =\n  _$LH;\n\ntype ChildPart = InstanceType<typeof ChildPart>;\ntype TemplateInstance = InstanceType<typeof TemplateInstance>;\n\n/**\n * Information needed to rehydrate a single TemplateResult.\n */\ntype ChildPartState =\n  | {\n      type: 'leaf';\n      /** The ChildPart that the result is rendered to */\n      part: ChildPart;\n    }\n  | {\n      type: 'iterable';\n      /** The ChildPart that the result is rendered to */\n      part: ChildPart;\n      value: Iterable<unknown>;\n      iterator: Iterator<unknown>;\n      done: boolean;\n    }\n  | {\n      type: 'template-instance';\n      /** The ChildPart that the result is rendered to */\n      part: ChildPart;\n\n      result: TemplateResult;\n\n      /** The TemplateInstance created from the TemplateResult */\n      instance: TemplateInstance;\n\n      /**\n       * The index of the next Template part to be hydrated. This is mutable and\n       * updated as the tree walk discovers new part markers at the right level in\n       * the template instance tree.  Note there is only one Template part per\n       * attribute with (one or more) bindings.\n       */\n      templatePartIndex: number;\n\n      /**\n       * The index of the next TemplateInstance part to be hydrated. This is used\n       * to retrieve the value from the TemplateResult and initialize the\n       * TemplateInstance parts' values for dirty-checking on first render.\n       */\n      instancePartIndex: number;\n    };\n\n/**\n * hydrate() operates on a container with server-side rendered content and\n * restores the client side data structures needed for lit-html updates such as\n * TemplateInstances and Parts. After calling `hydrate`, lit-html will behave as\n * if it initially rendered the DOM, and any subsequent updates will update\n * efficiently, the same as if lit-html had rendered the DOM on the client.\n *\n * hydrate() must be called on DOM that adheres the to lit-ssr structure for\n * parts. ChildParts must be represented with both a start and end comment\n * marker, and ChildParts that contain a TemplateInstance must have the template\n * digest written into the comment data.\n *\n * Since render() encloses its output in a ChildPart, there must always be a root\n * ChildPart.\n *\n * Example (using for # ... for annotations in HTML)\n *\n * Given this input:\n *\n *   html`<div class=${x}>${y}</div>`\n *\n * The SSR DOM is:\n *\n *   <!--lit-part AEmR7W+R0Ak=-->  # Start marker for the root ChildPart created\n *                                 # by render(). Includes the digest of the\n *                                 # template\n *   <div class=\"TEST_X\">\n *     <!--lit-node 0--> # Indicates there are attribute bindings here\n *                           # The number is the depth-first index of the parent\n *                           # node in the template.\n *     <!--lit-part-->  # Start marker for the ${x} expression\n *     TEST_Y\n *     <!--/lit-part-->  # End marker for the ${x} expression\n *   </div>\n *\n *   <!--/lit-part-->  # End marker for the root ChildPart\n *\n * @param rootValue\n * @param container\n * @param userOptions\n */\nexport const hydrate = (\n  rootValue: unknown,\n  container: Element | DocumentFragment,\n  options: Partial<RenderOptions> = {}\n) => {\n  // TODO(kschaaf): Do we need a helper for _$litPart$ (\"part for node\")?\n  // This property needs to remain unminified.\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  if ((container as any)['_$litPart$'] !== undefined) {\n    throw new Error('container already contains a live render');\n  }\n\n  // Since render() creates a ChildPart to render into, we'll always have\n  // exactly one root part. We need to hold a reference to it so we can set\n  // it in the parts cache.\n  let rootPart: ChildPart | undefined = undefined;\n\n  // Used for error messages\n  let rootPartMarker: Comment | undefined = undefined;\n\n  // When we are in-between ChildPart markers, this is the current ChildPart.\n  // It's needed to be able to set the ChildPart's endNode when we see a\n  // close marker\n  let currentChildPart: ChildPart | undefined = undefined;\n\n  // Used to remember parent template state as we recurse into nested\n  // templates\n  const stack: Array<ChildPartState> = [];\n\n  const walker = document.createTreeWalker(\n    container,\n    NodeFilter.SHOW_COMMENT,\n    null,\n    false\n  );\n  let marker: Comment | null;\n\n  // Walk the DOM looking for part marker comments\n  while ((marker = walker.nextNode() as Comment | null) !== null) {\n    const markerText = marker.data;\n    if (markerText.startsWith('lit-part')) {\n      if (stack.length === 0 && rootPart !== undefined) {\n        throw new Error(\n          `There must be only one root part per container. ` +\n            `Found a part marker (${marker}) when we already have a root ` +\n            `part marker (${rootPartMarker})`\n        );\n      }\n      // Create a new ChildPart and push it onto the stack\n      currentChildPart = openChildPart(rootValue, marker, stack, options);\n      rootPart ??= currentChildPart;\n      rootPartMarker ??= marker;\n    } else if (markerText.startsWith('lit-node')) {\n      // Create and hydrate attribute parts into the current ChildPart on the\n      // stack\n      createAttributeParts(marker, stack, options);\n    } else if (markerText.startsWith('/lit-part')) {\n      // Close the current ChildPart, and pop the previous one off the stack\n      if (stack.length === 1 && currentChildPart !== rootPart) {\n        throw new Error('internal error');\n      }\n      currentChildPart = closeChildPart(marker, currentChildPart, stack);\n    }\n  }\n  if (rootPart === undefined) {\n    const elementMessage =\n      container instanceof ShadowRoot\n        ? `{container.host.localName}'s shadow root`\n        : container instanceof DocumentFragment\n        ? 'DocumentFragment'\n        : container.localName;\n    console.error(\n      `There should be exactly one root part in a render container, ` +\n        `but we didn't find any in ${elementMessage}.`\n    );\n  } // This property needs to remain unminified.\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  (container as any)['_$litPart$'] = rootPart;\n};\n\nconst openChildPart = (\n  rootValue: unknown,\n  marker: Comment,\n  stack: Array<ChildPartState>,\n  options: RenderOptions\n) => {\n  let value: unknown;\n  // We know the startNode now. We'll know the endNode when we get to\n  // the matching marker and set it in closeChildPart()\n  // TODO(kschaaf): Current constructor takes both nodes\n  let part;\n  if (stack.length === 0) {\n    part = new ChildPart(marker, null, undefined, options);\n    value = rootValue;\n  } else {\n    const state = stack[stack.length - 1];\n    if (state.type === 'template-instance') {\n      part = new ChildPart(marker, null, state.instance, options);\n      state.instance._$parts.push(part);\n      value = state.result.values[state.instancePartIndex++];\n      state.templatePartIndex++;\n    } else if (state.type === 'iterable') {\n      part = new ChildPart(marker, null, state.part, options);\n      const result = state.iterator.next();\n      if (result.done) {\n        value = undefined;\n        state.done = true;\n        throw new Error('Unhandled shorter than expected iterable');\n      } else {\n        value = result.value;\n      }\n      (state.part._$committedValue as Array<ChildPart>).push(part);\n    } else {\n      // state.type === 'leaf'\n      // TODO(kschaaf): This is unexpected, and likely a result of a primitive\n      // been rendered on the client when a TemplateResult was rendered on the\n      // server; this part will be hydrated but not used. We can detect it, but\n      // we need to decide what to do in this case. Note that this part won't be\n      // retained by any parent TemplateInstance, since a primitive had been\n      // rendered in its place.\n      // https://github.com/lit/lit/issues/1434\n      // throw new Error('Hydration value mismatch: Found a TemplateInstance' +\n      //  'where a leaf value was expected');\n      part = new ChildPart(marker, null, state.part, options);\n    }\n  }\n\n  // Initialize the ChildPart state depending on the type of value and push\n  // it onto the stack. This logic closely follows the ChildPart commit()\n  // cascade order:\n  // 1. directive\n  // 2. noChange\n  // 3. primitive (note strings must be handled before iterables, since they\n  //    are iterable)\n  // 4. TemplateResult\n  // 5. Node (not yet implemented, but fallback handling is fine)\n  // 6. Iterable\n  // 7. nothing (handled in fallback)\n  // 8. Fallback for everything else\n  value = resolveDirective(part, value);\n  if (value === noChange) {\n    stack.push({part, type: 'leaf'});\n  } else if (isPrimitive(value)) {\n    stack.push({part, type: 'leaf'});\n    part._$committedValue = value;\n    // TODO(kschaaf): We can detect when a primitive is being hydrated on the\n    // client where a TemplateResult was rendered on the server, but we need to\n    // decide on a strategy for what to do next.\n    // https://github.com/lit/lit/issues/1434\n    // if (marker.data !== 'lit-part') {\n    //   throw new Error('Hydration value mismatch: Primitive found where TemplateResult expected');\n    // }\n  } else if (isTemplateResult(value)) {\n    // Check for a template result digest\n    const markerWithDigest = `lit-part ${digestForTemplateResult(value)}`;\n    if (marker.data === markerWithDigest) {\n      const template = (\n        ChildPart.prototype as ChildPart & {\n          _$getTemplate(\n            value: TemplateResult\n          ): ConstructorParameters<typeof TemplateInstance>[0];\n        }\n      )._$getTemplate(value);\n      const instance = new TemplateInstance(template, part);\n      stack.push({\n        type: 'template-instance',\n        instance,\n        part,\n        templatePartIndex: 0,\n        instancePartIndex: 0,\n        result: value,\n      });\n      // For TemplateResult values, we set the part value to the\n      // generated TemplateInstance\n      part._$committedValue = instance;\n    } else {\n      // TODO: if this isn't the server-rendered template, do we\n      // need to stop hydrating this subtree? Clear it? Add tests.\n      throw new Error(\n        'Hydration value mismatch: Unexpected TemplateResult rendered to part'\n      );\n    }\n  } else if (isIterable(value)) {\n    // currentChildPart.value will contain an array of ChildParts\n    stack.push({\n      part: part,\n      type: 'iterable',\n      value,\n      iterator: value[Symbol.iterator](),\n      done: false,\n    });\n    part._$committedValue = [];\n  } else {\n    // Fallback for everything else (nothing, Objects, Functions,\n    // etc.): we just initialize the part's value\n    // Note that `Node` value types are not currently supported during\n    // SSR, so that part of the cascade is missing.\n    stack.push({part: part, type: 'leaf'});\n    part._$committedValue = value == null ? '' : value;\n  }\n  return part;\n};\n\nconst closeChildPart = (\n  marker: Comment,\n  part: ChildPart | undefined,\n  stack: Array<ChildPartState>\n): ChildPart | undefined => {\n  if (part === undefined) {\n    throw new Error('unbalanced part marker');\n  }\n\n  (part as ChildPart & {_$endNode: ChildNode})._$endNode = marker;\n\n  const currentState = stack.pop()!;\n\n  if (currentState.type === 'iterable') {\n    if (!currentState.iterator.next().done) {\n      throw new Error('unexpected longer than expected iterable');\n    }\n  }\n\n  if (stack.length > 0) {\n    const state = stack[stack.length - 1];\n    return state.part;\n  } else {\n    return undefined;\n  }\n};\n\nconst createAttributeParts = (\n  comment: Comment,\n  stack: Array<ChildPartState>,\n  options: RenderOptions\n) => {\n  // Get the nodeIndex from DOM. We're only using this for an integrity\n  // check right now, we might not need it.\n  const match = /lit-node (\\d+)/.exec(comment.data)!;\n  const nodeIndex = parseInt(match[1]);\n\n  // Node markers are added as a previous sibling to identify elements\n  // with attribute/property/element/event bindings or custom elements\n  // whose `defer-hydration` attribute needs to be removed\n  const node = comment.nextElementSibling;\n  if (node === null) {\n    throw new Error('could not find node for attribute parts');\n  }\n  // Remove `defer-hydration` attribute, if any\n  node.removeAttribute('defer-hydration');\n\n  const state = stack[stack.length - 1];\n  if (state.type === 'template-instance') {\n    const instance = state.instance;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      // If the next template part is in attribute-position on the current node,\n      // create the instance part for it and prime its state\n      const templatePart = instance._$template.parts[state.templatePartIndex];\n      if (\n        templatePart === undefined ||\n        (templatePart.type !== PartType.ATTRIBUTE &&\n          templatePart.type !== PartType.ELEMENT) ||\n        templatePart.index !== nodeIndex\n      ) {\n        break;\n      }\n\n      if (templatePart.type === PartType.ATTRIBUTE) {\n        // The instance part is created based on the constructor saved in the\n        // template part\n        const instancePart = new templatePart.ctor(\n          node as HTMLElement,\n          templatePart.name,\n          templatePart.strings,\n          state.instance,\n          options\n        );\n\n        const value = isSingleExpression(\n          instancePart as unknown as AttributePartInfo\n        )\n          ? state.result.values[state.instancePartIndex]\n          : state.result.values;\n\n        // Setting the attribute value primes committed value with the resolved\n        // directive value; we only then commit that value for event/property\n        // parts since those were not serialized, and pass `noCommit` for the\n        // others to avoid perf impact of touching the DOM unnecessarily\n        const noCommit = !(\n          instancePart.type === PartType.EVENT ||\n          instancePart.type === PartType.PROPERTY\n        );\n        (\n          instancePart as AttributePart & {\n            _$setValue(\n              value: unknown,\n              directiveParent: DirectiveParent,\n              valueIndex?: number,\n              noCommit?: boolean\n            ): void;\n          }\n        )._$setValue(value, instancePart, state.instancePartIndex, noCommit);\n        state.instancePartIndex += templatePart.strings.length - 1;\n        instance._$parts.push(instancePart);\n      } else {\n        // templatePart.type === PartType.ELEMENT\n        const instancePart = new ElementPart(node, state.instance, options);\n        resolveDirective(\n          instancePart,\n          state.result.values[state.instancePartIndex++]\n        );\n        instance._$parts.push(instancePart);\n      }\n      state.templatePartIndex++;\n    }\n  } else {\n    throw new Error('internal error');\n  }\n};\n\n// Number of 32 bit elements to use to create template digests\nconst digestSize = 2;\n// We need to specify a digest to use across rendering environments. This is a\n// simple digest build from a DJB2-ish hash modified from:\n// https://github.com/darkskyapp/string-hash/blob/master/index.js\n// It has been changed to an array of hashes to add additional bits.\n// Goals:\n//  - Extremely low collision rate. We may not be able to detect collisions.\n//  - Extremely fast.\n//  - Extremely small code size.\n//  - Safe to include in HTML comment text or attribute value.\n//  - Easily specifiable and implementable in multiple languages.\n// We don't care about cryptographic suitability.\nexport const digestForTemplateResult = (templateResult: TemplateResult) => {\n  const hashes = new Uint32Array(digestSize).fill(5381);\n\n  for (const s of templateResult.strings) {\n    for (let i = 0; i < s.length; i++) {\n      hashes[i % digestSize] = (hashes[i % digestSize] * 33) ^ s.charCodeAt(i);\n    }\n  }\n  const str = String.fromCharCode(...new Uint8Array(hashes.buffer));\n  // Use `btoa` in browsers because it is supported universally.\n  //\n  // In Node, we are sometimes executing in an isolated VM context, which means\n  // neither `btoa` nor `Buffer` will be globally available by default (also\n  // note that `btoa` is only supported in Node 16+ anyway, and we still support\n  // Node 14). Instead of requiring users to always provide an implementation\n  // for `btoa` when they set up their VM context, we instead inject an import\n  // for `Buffer` from Node's built-in `buffer` module in our Rollup config (see\n  // note at the top of this file), and use that.\n  return NODE_MODE ? Buffer.from(str, 'binary').toString('base64') : btoa(str);\n};\n", "/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n/**\n * LitElement support for hydration of content rendered using lit-ssr.\n *\n * @packageDocumentation\n */\n\nimport type {PropertyValues} from '@lit/reactive-element';\nimport {render, RenderOptions} from 'lit-html';\nimport {hydrate} from './lib/hydrate-lit-html.js';\n\n// Keep consistent with `@lit-labs/ssr-dom-shim`\nconst HYDRATE_INTERNALS_ATTR_PREFIX = 'hydrate-internals-';\n\ninterface PatchableLitElement extends HTMLElement {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-misused-new\n  new (...args: any[]): PatchableLitElement;\n  enableUpdating(requestedUpdate?: boolean): void;\n  createRenderRoot(): Element | ShadowRoot;\n  renderRoot: HTMLElement | DocumentFragment;\n  render(): unknown;\n  renderOptions: RenderOptions;\n  _$needsHydration: boolean;\n}\n\nglobalThis.litElementHydrateSupport = ({\n  LitElement,\n}: {\n  LitElement: PatchableLitElement;\n}) => {\n  const observedAttributes = Object.getOwnPropertyDescriptor(\n    Object.getPrototypeOf(LitElement),\n    'observedAttributes'\n  )!.get!;\n\n  // Add `defer-hydration` to observedAttributes\n  Object.defineProperty(LitElement, 'observedAttributes', {\n    get() {\n      return [...observedAttributes.call(this), 'defer-hydration'];\n    },\n  });\n\n  // Enable element when 'defer-hydration' attribute is removed by calling the\n  // super.connectedCallback()\n  const attributeChangedCallback =\n    LitElement.prototype.attributeChangedCallback;\n  LitElement.prototype.attributeChangedCallback = function (\n    name: string,\n    old: string | null,\n    value: string | null\n  ) {\n    if (name === 'defer-hydration' && value === null) {\n      connectedCallback.call(this);\n    }\n    attributeChangedCallback.call(this, name, old, value);\n  };\n\n  // Override `connectedCallback` to capture whether we need hydration, and\n  // defer `super.connectedCallback()` if the 'defer-hydration' attribute is set\n  const connectedCallback = LitElement.prototype.connectedCallback;\n  LitElement.prototype.connectedCallback = function (\n    this: PatchableLitElement\n  ) {\n    // If the outer scope of this element has not yet been hydrated, wait until\n    // 'defer-hydration' attribute has been removed to enable\n    if (!this.hasAttribute('defer-hydration')) {\n      connectedCallback.call(this);\n    }\n  };\n\n  // If we've been server-side rendered, just return `this.shadowRoot`, don't\n  // call the base implementation, which would also adopt styles (for now)\n  const createRenderRoot = LitElement.prototype.createRenderRoot;\n  LitElement.prototype.createRenderRoot = function (this: PatchableLitElement) {\n    if (this.shadowRoot) {\n      this._$needsHydration = true;\n      return this.shadowRoot;\n    } else {\n      return createRenderRoot.call(this);\n    }\n  };\n\n  // Hydrate on first update when needed\n  const update = Object.getPrototypeOf(LitElement.prototype).update;\n  LitElement.prototype.update = function (\n    this: PatchableLitElement,\n    changedProperties: PropertyValues\n  ) {\n    const value = this.render();\n    // Since this is a patch, we can't call super.update(), so we capture\n    // it off the proto chain and call it instead\n    update.call(this, changedProperties);\n    if (this._$needsHydration) {\n      this._$needsHydration = false;\n      // Remove aria attributes added by internals shim during SSR\n      for (let i = 0; i < this.attributes.length; i++) {\n        const attr = this.attributes[i];\n        if (attr.name.startsWith(HYDRATE_INTERNALS_ATTR_PREFIX)) {\n          const ariaAttr = attr.name.slice(\n            HYDRATE_INTERNALS_ATTR_PREFIX.length\n          );\n          this.removeAttribute(ariaAttr);\n          this.removeAttribute(attr.name);\n        }\n      }\n      hydrate(value, this.renderRoot, this.renderOptions);\n    } else {\n      render(value, this.renderRoot, this.renderOptions);\n    }\n  };\n};\n"],
  "mappings": "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",
  "names": ["_$LH", "boundAttributeSuffix", "p", "_boundAttributeSuffix", "marker", "_marker", "markerMatch", "_markerMatch", "HTML_RESULT", "_HTML_RESULT", "getTemplateHtml", "_getTemplateHtml", "overrideDirectiveResolve", "directiveClass", "resolveOverrideFn", "_$resolve", "_part", "values", "this", "setDirectiveClass", "value", "getAttributePartCommittedValue", "part", "index", "committedValue", "noChange", "_commitValue", "_$setValue", "connectedDisconnectable", "props", "_$isConnected", "resolveDirective", "_resolveDirective", "AttributePart", "_AttributePart", "PropertyPart", "_PropertyPart", "BooleanAttributePart", "_BooleanAttributePart", "EventPart", "_EventPart", "ElementPart", "_ElementPart", "TemplateInstance", "_TemplateInstance", "isIterable", "_isIterable", "ChildPart", "_ChildPart", "TemplateInstance", "isIterable", "resolveDirective", "ChildPart", "ElementPart", "_$LH", "hydrate", "rootValue", "container", "options", "Error", "rootPart", "rootPartMarker", "currentChildPart", "stack", "walker", "document", "createTreeWalker", "NodeFilter", "SHOW_COMMENT", "marker", "nextNode", "markerText", "data", "startsWith", "length", "openChildPart", "createAttributeParts", "closeChildPart", "elementMessage", "ShadowRoot", "DocumentFragment", "localName", "console", "error", "value", "part", "state", "type", "instance", "_$parts", "push", "result", "values", "instancePartIndex", "templatePartIndex", "iterator", "next", "done", "_$committedValue", "noChange", "isPrimitive", "isTemplateResult", "markerWithDigest", "digestForTemplateResult", "template", "prototype", "_$getTemplate", "Symbol", "_$endNode", "currentState", "pop", "comment", "match", "exec", "nodeIndex", "parseInt", "node", "nextElementSibling", "removeAttribute", "templatePart", "_$template", "parts", "PartType", "ATTRIBUTE", "ELEMENT", "index", "instancePart", "ctor", "name", "strings", "isSingleExpression", "noCommit", "EVENT", "PROPERTY", "_$setValue", "templateResult", "hashes", "Uint32Array", "fill", "s", "i", "charCodeAt", "str", "String", "fromCharCode", "Uint8Array", "buffer", "btoa", "globalThis", "litElementHydrateSupport", "LitElement", "observedAttributes", "Object", "getOwnPropertyDescriptor", "getPrototypeOf", "get", "defineProperty", "call", "this", "attributeChangedCallback", "prototype", "name", "old", "value", "connectedCallback", "hasAttribute", "createRenderRoot", "shadowRoot", "_$needsHydration", "update", "changedProperties", "render", "i", "attributes", "length", "attr", "startsWith", "ariaAttr", "slice", "HYDRATE_INTERNALS_ATTR_PREFIX", "removeAttribute", "hydrate", "renderRoot", "renderOptions"]
}
