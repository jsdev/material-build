{
  "version": 3,
  "sources": ["../../../node_modules/@webcomponents/template-shadowroot/src/_implementation/feature_detect.ts", "../../../node_modules/@webcomponents/template-shadowroot/src/_implementation/util.ts", "../../../node_modules/@webcomponents/template-shadowroot/src/_implementation/manual_walk.ts", "../../src/ssr-utils/dsd-polyfill.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n// lib.dom.ts is out of date, so declare our own parseFromString here.\ninterface DOMParser {\n  parseFromString(string: string, type: DOMParserSupportedType, options?: {\n    includeShadowRoots: boolean;\n  }): Document;\n}\n\n// This isn't ideal. Setting .innerHTML is not compatible with some\n// TrustedTypes CSP policies. Discussion at:\n//     https://github.com/mfreed7/declarative-shadow-dom/issues/3\nlet hasNative: boolean|undefined;\nexport function hasNativeDeclarativeShadowRoots(): boolean {\n  if (hasNative === undefined) {\n    const html = `<div><template shadowrootmode=\"open\"></template></div>`;\n    const fragment = (new DOMParser() as DOMParser).parseFromString(html, 'text/html', {\n      includeShadowRoots: true\n    });\n    hasNative = !!fragment.querySelector('div')?.shadowRoot;\n  }\n  return hasNative;\n}\n", "/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nexport const hasNoParentElement =\n    (e: Element|DocumentFragment): e is DocumentFragment =>\n        e.parentElement === null;\nexport const isTemplate = (e: Node): e is HTMLTemplateElement =>\n    (e as Partial<Element>).tagName === 'TEMPLATE';\nexport const isElement = (e: Node): e is HTMLElement =>\n    e.nodeType === Node.ELEMENT_NODE;\n", "/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {hasNativeDeclarativeShadowRoots} from './feature_detect.js';\nimport {hasNoParentElement, isElement, isTemplate} from './util.js';\n\n/*\n * Traverses the DOM to find all <template> elements with a `shadowrootmode`\n * attribute and move their content into a ShadowRoot on their parent element.\n *\n * This processing is done bottom up so that when top-level <template>\n * elements are hydrated, their contents are already hydrated and in the\n * final correct structure of elements and shadow roots.\n */\nexport const hydrateShadowRoots = (root: ParentNode) => {\n  if (hasNativeDeclarativeShadowRoots()) {\n    return;  // nothing to do\n  }\n\n  // Approaches to try and benchmark:\n  //  - manual walk (current implementation)\n  //  - querySelectorAll\n  //  - TreeWalker\n\n  // Stack of nested templates that we're currently processing. Use to\n  // remember how to get from a <template>.content DocumentFragment back to\n  // its owner <template>\n  const templateStack: Array<HTMLTemplateElement> = [];\n\n  let currentNode: Element|DocumentFragment|null = root.firstElementChild;\n\n  // The outer loop traverses down, looking for <template shadowrootmode>\n  // elements. The inner loop traverses back up, hydrating them in a postorder\n  // traversal.\n  while (currentNode !== root && currentNode !== null) {\n    if (isTemplate(currentNode)) {\n      templateStack.push(currentNode);\n      currentNode = currentNode.content;\n    } else if (currentNode.firstElementChild !== null) {\n      // Traverse down\n      currentNode = currentNode.firstElementChild;\n    } else if (\n        isElement(currentNode) && currentNode.nextElementSibling !== null) {\n      // Element is empty, but has a next sibling. Traverse that.\n      currentNode = currentNode.nextElementSibling;\n    } else {\n      // Element is empty and the last child. Traverse to next aunt/grandaunt.\n\n      // Store templates we hydrate for one loop so that we can remove them\n      // *after* traversing to their successor.\n      let template: HTMLTemplateElement|undefined;\n\n      while (currentNode !== root && currentNode !== null) {\n        if (hasNoParentElement(currentNode)) {\n          // We must be at a <template>'s content fragment.\n          template = templateStack.pop()!;\n          const host = template.parentElement!;\n          const mode = template.getAttribute('shadowrootmode');\n          currentNode = template;\n          if (mode === 'open' || mode === 'closed') {\n            const delegatesFocus =\n                template.hasAttribute('shadowrootdelegatesfocus');\n            try {\n              const shadow = host.attachShadow({mode, delegatesFocus});\n              shadow.append(template.content);\n            } catch {\n              // there was already a shadow root.\n              // TODO(rictic): log an error event?\n            }\n          } else {\n            template = undefined;\n          }\n        } else {\n          const nextSibling: Element|null|undefined =\n              currentNode.nextElementSibling;\n          if (nextSibling != null) {\n            currentNode = nextSibling;\n            if (template !== undefined) {\n              template.parentElement!.removeChild(template);\n            }\n            break;\n          }\n          const nextAunt: Element|null|undefined =\n              currentNode.parentElement?.nextElementSibling;\n          if (nextAunt != null) {\n            currentNode = nextAunt;\n            if (template !== undefined) {\n              template.parentElement!.removeChild(template);\n            }\n            break;\n          }\n          currentNode = currentNode.parentElement;\n          if (template !== undefined) {\n            template.parentElement!.removeChild(template);\n            template = undefined;\n          }\n        }\n      }\n    }\n  }\n};\n", "/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// Declarative shadow dom polyfill\nimport {hydrateShadowRoots} from '@webcomponents/template-shadowroot/template-shadowroot.js';\n\nif (!HTMLTemplateElement.prototype.hasOwnProperty('shadowRoot')) {\n  hydrateShadowRoots(document.body);\n}\ndocument.body.removeAttribute('dsd-pending');\n"],
  "mappings": ";;;AAgBA,MAAI;AACE,WAAU,kCAA+B;;AAC7C,QAAI,cAAc,QAAW;AAC3B,YAAM,OAAO;AACb,YAAM,WAAY,IAAI,UAAS,EAAiB,gBAAgB,MAAM,aAAa;QACjF,oBAAoB;OACrB;AACD,kBAAY,CAAC,GAAC,KAAA,SAAS,cAAc,KAAK,OAAC,QAAA,OAAA,SAAA,SAAA,GAAE;;AAE/C,WAAO;EACT;;;ACpBO,MAAM,qBACT,CAAC,MACG,EAAE,kBAAkB;AACrB,MAAM,aAAa,CAAC,MACtB,EAAuB,YAAY;AACjC,MAAM,YAAY,CAAC,MACtB,EAAE,aAAa,KAAK;;;ACKjB,MAAM,qBAAqB,CAAC,SAAoB;;AACrD,QAAI,gCAA+B,GAAI;AACrC;;AAWF,UAAM,gBAA4C,CAAA;AAElD,QAAI,cAA6C,KAAK;AAKtD,WAAO,gBAAgB,QAAQ,gBAAgB,MAAM;AACnD,UAAI,WAAW,WAAW,GAAG;AAC3B,sBAAc,KAAK,WAAW;AAC9B,sBAAc,YAAY;iBACjB,YAAY,sBAAsB,MAAM;AAEjD,sBAAc,YAAY;iBAExB,UAAU,WAAW,KAAK,YAAY,uBAAuB,MAAM;AAErE,sBAAc,YAAY;aACrB;AAKL,YAAI;AAEJ,eAAO,gBAAgB,QAAQ,gBAAgB,MAAM;AACnD,cAAI,mBAAmB,WAAW,GAAG;AAEnC,uBAAW,cAAc,IAAG;AAC5B,kBAAM,OAAO,SAAS;AACtB,kBAAM,OAAO,SAAS,aAAa,gBAAgB;AACnD,0BAAc;AACd,gBAAI,SAAS,UAAU,SAAS,UAAU;AACxC,oBAAM,iBACF,SAAS,aAAa,0BAA0B;AACpD,kBAAI;AACF,sBAAM,SAAS,KAAK,aAAa,EAAC,MAAM,eAAc,CAAC;AACvD,uBAAO,OAAO,SAAS,OAAO;sBAC9B;;mBAIG;AACL,yBAAW;;iBAER;AACL,kBAAM,cACF,YAAY;AAChB,gBAAI,eAAe,MAAM;AACvB,4BAAc;AACd,kBAAI,aAAa,QAAW;AAC1B,yBAAS,cAAe,YAAY,QAAQ;;AAE9C;;AAEF,kBAAM,YACF,KAAA,YAAY,mBAAa,QAAA,OAAA,SAAA,SAAA,GAAE;AAC/B,gBAAI,YAAY,MAAM;AACpB,4BAAc;AACd,kBAAI,aAAa,QAAW;AAC1B,yBAAS,cAAe,YAAY,QAAQ;;AAE9C;;AAEF,0BAAc,YAAY;AAC1B,gBAAI,aAAa,QAAW;AAC1B,uBAAS,cAAe,YAAY,QAAQ;AAC5C,yBAAW;;;;;;EAMvB;;;AC9FA,MAAI,CAAC,oBAAoB,UAAU,eAAe,YAAY,GAAG;AAC/D,uBAAmB,SAAS,IAAI;AAAA,EAClC;AACA,WAAS,KAAK,gBAAgB,aAAa;",
  "names": []
}
